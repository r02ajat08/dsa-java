ğŸ§  What Is Recursion?
Recursion is when a function calls itself to solve smaller subproblems.
Every recursion has two key parts:

ğŸ§± Base Case â€“ when to stop

ğŸ”„ Recursive Case â€“ break the problem down

ğŸ“¦ When to Use Recursion?
ğŸ’¬ If problem mentions...	ğŸ’¡ Recursion might help when...
"All combinations / permutations"	Try every possible option (backtracking)
"Tree traversal / divide structure"	Natural recursive structure (e.g., binary tree)
"Subproblem of subproblem..."	Break problem into smaller versions of itself
"Count/Generate paths or ways"	Explore all choices recursively
"Try every path or decision"	Need to explore all possible states

ğŸ§© Recursion Patterns
ğŸ”¢	Pattern	Use Case / Description
1ï¸âƒ£	Basic Recursion	Factorial, Fibonacci, Power, Sum
2ï¸âƒ£	Backtracking	Generate combinations/permutations, N-Queens
3ï¸âƒ£	DFS Recursion	Trees, Graphs, Grid traversal
4ï¸âƒ£	Divide & Conquer	Merge Sort, Quick Sort, Binary Search
5ï¸âƒ£	Subset/Permutation	Use for loop and recursive calls
6ï¸âƒ£	Memoized Recursion (DP)	Use HashMap or array to store intermediate results

ğŸ“¦ Java Code Templates
â• Factorial (basic recursion)
java
Copy
Edit
int fact(int n) {
    if (n == 0) return 1; // base case
    return n * fact(n - 1); // recursive step
}
ğŸ” Print all subsets (backtracking)
java
Copy
Edit
void generateSubsets(int[] nums, int index, List<Integer> curr) {
    if (index == nums.length) {
        System.out.println(curr);
        return;
    }

    // Include current element
    curr.add(nums[index]);
    generateSubsets(nums, index + 1, curr);

    // Exclude current element
    curr.remove(curr.size() - 1);
    generateSubsets(nums, index + 1, curr);
}



ğŸ” Step 1: Understand the Problem
âœï¸ "Can I break this problem into smaller subproblems of the same type?"

Ask yourself:

Do I need to try all combinations?

Does the problem have a natural repeatable structure?

Does it mention trees, graphs, or sequences?

âœ… If YES â†’ recursion might be your tool!

ğŸ§± Step 2: Identify the Base Case
"When should the recursion stop?"

âœ… Base Case Example	Problem
if (n == 0) return 1;	Factorial
if (index == arr.length)	Subset generation complete
if (node == null)	Tree traversal

ğŸ”” Without a base case â†’ Infinite recursion (ğŸ’¥ stack overflow)!

ğŸ”„ Step 3: Define the Recursive Step
"What smaller piece can I solve recursively?"

Ask:

Whatâ€™s the subproblem?

How do I move toward the base case?

Can I delegate part of the work to recursion?

ğŸ§© Example	Recursive Logic
fact(n) = n * fact(n - 1)	Factorial breaks into smaller products
dfs(index + 1)	Move forward in list/string
sum(n) = n + sum(n - 1)	Reduce problem size each time

ğŸ§ª Step 4: Try Dry Run or Tree Diagram
Visualize small input (like n = 2 or abc)
Draw the recursion tree to see how calls break and return.

ğŸŒ² Example for subsets([1, 2]):

css
Copy
Edit
            []
         /      \
      [1]       []
     /   \     /   \
 [1,2]  [1]  [2]   []
âœ¨ Step 5: Add Parameters Thoughtfully
What info must I pass with each call?

What changes in each call (index, string, sum, path)?

java
Copy
Edit
void recurse(int index, List<Integer> path) {
    // index â†’ where we are
    // path  â†’ current answer in progress
}
ğŸ’¾ Step 6: Add Return Values (if needed)
Some recursive functions return values (sum, true/false, etc.)

Use the result from recursive call

Combine or check conditions

java
Copy
Edit
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}
ğŸ›¡ Step 7: Handle Edge Cases
Empty input

Duplicates

Deep recursion (use memoization if needed)

Infinite recursion guard (base case!)

ğŸ’¡ Recursion Design Checklist âœ…
Question	Example
Do I know the base case?	if (i == n)
Do I reduce input every call?	recurse(i + 1)
Do I reach base eventually?	Yes, always a smaller input
Am I combining results correctly?	Sum, paths, booleans
Do I reuse results? (Memoization)	Use Map or dp[]


