ğŸ¯ Why Use Monotonic Stack / Queue?
Monotonic data structures help you solve problems where you need to:

âœ… Efficiently find relationships between elements like:
Next Greater / Smaller Element

Previous Greater / Smaller Element

Max / Min in sliding window

Instead of checking every pair (which takes O(nÂ²)), you use a monotonic structure to do it in O(n) time!

ğŸ§  How It Works (Simple Idea):
You maintain order in a stack or queue:

ğŸ”¼ Increasing â†’ smallest on top

ğŸ”½ Decreasing â†’ largest on top

You pop unnecessary elements â€” keeping only useful ones for future comparisons.

ğŸ”„ Real-Life Analogy:
ğŸ“¦ Imagine you're stacking boxes where you only care about taller boxes coming next.
If a new box is taller than the top one, you pop the shorter one â€” because it's useless now.
Thatâ€™s what a monotonic stack does! ğŸ§±â¡ï¸ğŸ§±â¡ï¸ğŸ“

ğŸ›  Use Cases in DSA
ğŸ’¬ Problem Type	ğŸ” Why Use Monotonic Stack/Queue?
Next Greater Element	Efficiently skip all smaller elements
Sliding Window Maximum/Minimum	Maintain max/min without rechecking window
Largest Rectangle in Histogram	Helps find bounds for area calculation
Stock Span Problem	Track previous days with lower prices
Drop smaller/larger during iteration	Remove useless elements in O(1)

ğŸ“ˆ Why Not Just Loop?
âŒ Brute-force:
java
Copy
Edit
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) {
        // Compare each pair â†’ O(nÂ²)
    }
}
âœ… Monotonic Stack:
java
Copy
Edit
// Push, Pop only once â†’ O(n)
This saves tons of time, especially in long arrays! ğŸ•’

âš¡ Summary
ğŸ“Œ Advantage	âœ… Yes!
Reduces time from O(nÂ²) to O(n)	âœ…
Keeps track of useful elements	âœ…
Can combine with Sliding Window	âœ… (for max/min window problems)

